---
description: Guide for writing AI-executable task definitions with objective criteria and explicit instructions
alwaysApply: false
---

# AI Task Writing Guide

Best practices for writing task definitions that AI tools can execute successfully on first attempt.

---

## Core Principles

1. **Objective Over Subjective** - AI can validate "‚â§50 lines" but not "clean code"
2. **Explicit Over Implicit** - AI needs exact code, not "integrate appropriately"
3. **Validatable Over Aspirational** - Every criterion needs validation command
4. **Incremental Over Big-Bang** - Validate after each step, not just at end
5. **Referenced Over Assumed** - Show actual code, don't assume AI knows your codebase

---

## Principle 1: Objective Over Subjective

AI cannot validate subjective criteria. Replace with objectively measurable criteria.

## Comprehensive Subjective Language Reference

**Forbidden Terms with Objective Replacements:**

| Subjective Term | Why It's Bad | Objective Replacement Example |
|----------------|--------------|-------------------------------|
| "distinct visual design" | Can't measure "distinct" | "Uses background='secondary' for container vs background='primary' in parent" <br> Validation: `grep 'background="secondary"' file.tsx` |
| "clean hierarchy" | Subjective aesthetics | "Heading uses size='large', body uses size='small'" <br> Validation: `grep 'size="large"' file.tsx` |
| "proper structure" | Undefined standard | "Uses Box > Stack > Text nesting pattern" <br> Validation: `grep -A 3 "<Box" file.tsx \| grep "<Stack"` |
| "appropriate spacing" | Undefined spacing | "Uses space='medium' token from Easel" <br> Validation: `grep 'space="medium"' file.tsx` |
| "well-organized code" | Subjective organization | "Maximum 3 nesting levels in functions" <br> Validation: `awk nesting depth check ‚â§3` |
| "good performance" | Undefined benchmark | "Component renders in <50ms" <br> Validation: `npm run test:perf -- ComponentName` |
| "elegant solution" | Aesthetic judgment | "Function is ‚â§30 lines with no nested conditionals" <br> Validation: `wc -l ‚â§30 && !grep nested` |
| "properly exported" | Undefined correctness | "Component exports via index.ts with named export" <br> Validation: `grep 'export { Component }' index.ts` |
| "correctly implemented" | Circular definition | "All functional requirements have passing tests" <br> Validation: `npm run test -- 6 passing` |
| "suitable approach" | Subjective suitability | "Uses early returns with no else blocks" <br> Validation: `!grep ' else ' file.ts` |
| "intuitive UX" | User perception | "Tab order matches visual top-to-bottom order" <br> Validation: Manual tab navigation test |
| "professional appearance" | Aesthetic judgment | "Uses Easel color tokens (primary/secondary/tertiary)" <br> Validation: `grep 'color="primary\|secondary"' file.tsx` |
| "optimal configuration" | Undefined optimality | "Autoplay=false, mute=true per performance guidelines" <br> Validation: `grep 'autoplay={false}' file.tsx` |
| "comprehensive coverage" | Undefined scope | "90%+ test coverage measured by coverage tool" <br> Validation: `npm run test:coverage -- ‚â•90%` |
| "well-documented" | Subjective quality | "JSDoc on all exported functions (count matches exports)" <br> Validation: `grep '/\*\*' count == export count` |

**Automated Detection:**
```bash
# Check for ANY subjective terms in success criteria
grep -A 100 "## Success Criteria" task.md | \
  grep -i -E "distinct|clean|proper|appropriate|nice|elegant|suitable|good|better|improved|correct|well-|optimal|comprehensive|intuitive|professional"
```

**If matches found:**
1. Identify each subjective term
2. Look up objective replacement in table above
3. Rewrite criterion with specific measurement
4. Add corresponding validation to ValidationScripts section
5. Re-run check until no matches

### Example 1: Component Design Quality

**‚ùå Subjective (AI cannot validate):**
```markdown
## Success Criteria
- [ ] Component has clean design
- [ ] Visual hierarchy is clear
- [ ] Layout is intuitive
- [ ] Styling is consistent
```

**‚úÖ Objective (AI can validate):**
```markdown
## Success Criteria

- [ ] Component uses Box from Easel for container (not custom div)
- [ ] Heading uses Text component with size="large" and weight="bold"
- [ ] Body uses Text component with size="small" and color="secondary"
- [ ] Two-column layout uses Columns component with width="3/5" and width="2/5"
- [ ] No custom CSS files (.css) in component directory
- [ ] All color values use Easel tokens (primary/secondary/tertiary)

## Validation Scripts

**Validation 1: Easel Box Usage**
```bash
grep "import { Box } from '@canva/ui/box'" component.tsx
```
Expected: Match found

**Validation 2: Typography Hierarchy**
```bash
grep 'size="large"' component.tsx && grep 'size="small"' component.tsx
```
Expected: Both matches found

**Validation 3: Column Layout**
```bash
grep 'width="3/5"' component.tsx && grep 'width="2/5"' component.tsx
```
Expected: Both matches found

**Validation 4: No Custom CSS**
```bash
find component-dir/ -name "*.css"
```
Expected: No files found (empty output)

**Validation 5: Easel Color Tokens**
```bash
grep 'color="primary\|secondary\|tertiary"' component.tsx
```
Expected: Matches found (no hex colors like #ffffff)
```

---

### Example 2: Code Quality Assessment

**‚ùå Subjective:**
```markdown
- [ ] Code follows best practices
- [ ] Implementation is elegant
- [ ] Function is well-structured
```

**‚úÖ Objective:**
```markdown
## Success Criteria

- [ ] No else blocks used (early returns only per ControlFlowConstraints)
- [ ] Function implementation is ‚â§20 lines
- [ ] Maximum nesting depth is ‚â§3 levels
- [ ] All imports use individual paths (no barrel imports from '@canva/ui')

## Validation Scripts

**Validation 1: No Else Blocks**
```bash
grep " else " file.ts
```
Expected: No matches (empty output)

**Validation 2: Function Length**
```bash
wc -l file.ts
```
Expected: ‚â§20 lines

**Validation 3: Nesting Depth**
```bash
awk '{print gsub(/\t/, "")}' file.ts | sort -rn | head -n 1
```
Expected: ‚â§3

**Validation 4: Individual Imports**
```bash
grep "from '@canva/ui'" file.tsx
```
Expected: No matches (only individual paths like '@canva/ui/box')
```

---

### Example 3: Performance Assessment

**‚ùå Subjective:**
```markdown
- [ ] Component is performant
- [ ] Function is fast enough
- [ ] Loads quickly
```

**‚úÖ Objective:**
```markdown
## Success Criteria

- [ ] Component renders in <50ms on average
- [ ] Function completes in <100ms for input size ‚â§1000 items
- [ ] Initial bundle size increase is <10KB
- [ ] No layout shift (CLS score <0.1)

## Validation Scripts

**Validation 1: Render Performance**
```bash
npm run test:perf -- ComponentName
```
Expected: "avg render: <50ms" in output

**Validation 2: Function Performance**
```bash
npm run test -- functionPerformance.test.ts
```
Expected: Test passes with timing assertion <100ms

**Validation 3: Bundle Size**
```bash
npm run build:analyze -- --compare
```
Expected: Size increase shown as "+8.2KB" or less

**Validation 4: Layout Shift**
```bash
npm run lighthouse -- --only-categories=performance
```
Expected: CLS score <0.1
```

---

## Principle 2: Explicit Over Implicit

AI cannot infer context or "figure out" details. Show exact code AI should write.

### Example 1: Component Integration

**‚ùå Implicit (AI must guess):**
```markdown
**Implementation:**
- Integrate YoutubePlayer component with appropriate settings
- Follow design system conventions
- Use TypeScript properly
```

**‚úÖ Explicit (AI knows exactly what to do):**
```markdown
## Required Imports (EXACT PATHS)

```typescript
// Video Player - YouTube integration
import { YoutubePlayer } from 'ui/tailoring/ui/video/youtube_player/youtube_player';
import type { YouTubeVideoPlayerTarget } from 'ui/tailoring/ui/video/youtube_player/youtube_player';

// Easel Design System - Individual imports
import { Box } from '@canva/ui/box';
import { Columns, Column } from '@canva/ui/columns';
```

## Implementation Steps

**Step 1: Import YoutubePlayer** (5 lines)
```typescript
// File: app_video_card.tsx
// Add to top of file with other imports:

import { YoutubePlayer } from 'ui/tailoring/ui/video/youtube_player/youtube_player';
import type { YouTubeVideoPlayerTarget } from 'ui/tailoring/ui/video/youtube_player/youtube_player';
```

**Validation After Step 1:**
```bash
grep "YoutubePlayer" app_video_card.tsx
npm run typecheck
```
Expected: Match found, 0 errors

‚úÖ **Checkpoint**

---

**Step 2: Use YoutubePlayer with Exact Configuration** (8 lines)
```typescript
// File: app_video_card.tsx
// Inside video column, add:

<YoutubePlayer
  mode="inline"
  videoId={videoId}
  aspectRatio="16:9"
  autoplay={false}
  mute={true}
/>
```

**Validation After Step 2:**
```bash
grep 'mode="inline"' app_video_card.tsx
grep 'autoplay={false}' app_video_card.tsx
```
Expected: Both matches found

‚úÖ **Checkpoint**
```

---

## Principle 3: Validatable Over Aspirational

Every success criterion needs a command AI can execute to verify completion.

### Example 1: Export Validation

**‚ùå Not Validatable:**
```markdown
- [ ] Component properly exported
- [ ] Module can be imported
```

**‚úÖ Validatable:**
```markdown
## Success Criteria

- [ ] Component exports from index.ts with named export
- [ ] Component is importable without errors
- [ ] TypeScript type definitions export correctly

## Validation Scripts

**Validation 1: Named Export**
```bash
grep "export { AppVideoCard }" index.ts
```
Expected: Match found

**Validation 2: Import Success**
```bash
node -e "const { AppVideoCard } = require('./dist'); console.log(typeof AppVideoCard);"
```
Expected: Output "function"

**Validation 3: Type Exports**
```bash
grep "export type AppVideoCardProps" types.ts
```
Expected: Match found
```

---

### Example 2: Test Coverage

**‚ùå Not Validatable:**
```markdown
- [ ] Tests are comprehensive
- [ ] All scenarios covered
```

**‚úÖ Validatable:**
```markdown
## Success Criteria

- [ ] Test suite has ‚â•6 test cases (one per functional requirement)
- [ ] Video rendering scenario has dedicated test
- [ ] Non-video fallback scenario has dedicated test
- [ ] All tests pass without failures

## Validation Scripts

**Validation 1: Test Count**
```bash
grep "describe\|it\|test(" test.ts | wc -l
```
Expected: ‚â•6

**Validation 2: Video Rendering Test**
```bash
grep "when videoId is provided" test.ts
```
Expected: Match found

**Validation 3: Fallback Test**
```bash
grep "when videoId is not provided" test.ts
```
Expected: Match found

**Validation 4: All Tests Pass**
```bash
npm run test app_video_card
```
Expected: "6 passing", exit code 0
```

---

## Principle 4: Incremental Over Big-Bang

Break implementation into small steps with validation after each step.

## Step Size Enforcement Examples

### ‚ùå Step Too Large (>20 lines - violates framework)

```markdown
**Step 3: Add Complete Component Implementation** (70 lines)
```typescript
export const AppVideoCard: React.FC<Props> = (props) => {
  const { videoId, title, iconUrl, heading, subheading, onClick } = props;

  if (!videoId) {
    return (
      <BasicButton onClick={onClick}>
        <Box padding="medium" background="primary">
          <Columns spacing="small">
            <Column width="content">
              <StaticImage src={iconUrl} alt={title} />
            </Column>
            <Column>
              <Stack space="small">
                <Text size="large" weight="bold">{heading}</Text>
                <Text size="small" color="secondary">{subheading}</Text>
              </Stack>
            </Column>
          </Columns>
        </Box>
      </BasicButton>
    );
  }

  return (
    <BasicButton onClick={onClick}>
      <Box padding="medium" background="secondary">
        <Columns spacing="large">
          <Column width="3/5">
            <Box background="tertiary" padding="small">
              <YoutubePlayer
                mode="inline"
                videoId={videoId}
                aspectRatio="16:9"
                autoplay={false}
                mute={true}
              />
            </Box>
          </Column>
          <Column width="2/5">
            <Stack space="small">
              <StaticImage src={iconUrl} alt={title} />
              <Text size="large" weight="bold">{heading}</Text>
              <Text size="small" color="secondary">{subheading}</Text>
            </Stack>
          </Column>
        </Columns>
      </Box>
    </BasicButton>
  );
};
```
```

**Problems:**
- 70 lines in one step (violates ‚â§20 line constraint)
- AI can't validate incrementally
- If early part wrong, wastes time on later parts
- No checkpoint gates

---

### ‚úÖ Step Properly Sized (‚â§20 lines each)

```markdown
**Step 3a: Add No-Video Early Return** (12 lines)
```typescript
// File: app_video_card.tsx
// Add after const destructuring:

if (!videoId) {
  return (
    <BasicButton onClick={onClick}>
      <Box padding="medium" background="primary">
        <Text>App info only - full implementation in step 3b</Text>
      </Box>
    </BasicButton>
  );
}
```

**Validation After Step 3a:**
```bash
grep "if (!videoId)" app_video_card.tsx
wc -l app_video_card.tsx
```
Expected: Match found, ‚â§30 total lines so far

‚úÖ **Checkpoint:** Proceed to 3b ONLY if validation passes

---

**Step 3b: Add Video Section Container** (15 lines)
```typescript
// File: app_video_card.tsx
// Add after early return:

return (
  <BasicButton onClick={onClick}>
    <Box padding="medium" background="secondary">
      <Columns spacing="large">
        <Column width="3/5">
          {/* Video in next step */}
        </Column>
        <Column width="2/5">
          {/* App info in step after */}
        </Column>
      </Columns>
    </Box>
  </BasicButton>
);
```

**Validation After Step 3b:**
```bash
grep 'width="3/5"' app_video_card.tsx
grep 'background="secondary"' app_video_card.tsx
```
Expected: Both matches found

‚úÖ **Checkpoint:** Proceed to 3c ONLY if validation passes

---

**Step 3c: Add YoutubePlayer to Video Column** (10 lines)
```typescript
// File: app_video_card.tsx
// Replace `{/* Video in next step */}` with:

<Box background="tertiary" padding="small" borderRadius="medium">
  <YoutubePlayer
    mode="inline"
    videoId={videoId}
    aspectRatio="16:9"
    autoplay={false}
    mute={true}
  />
</Box>
```

**Validation After Step 3c:**
```bash
grep "YoutubePlayer" app_video_card.tsx
grep 'background="tertiary"' app_video_card.tsx
wc -l app_video_card.tsx
```
Expected: Both matches found, ‚â§55 total lines

‚úÖ **Checkpoint:** Proceed to 3d ONLY if validation passes

---

**Step 3d: Add App Info to Second Column** (18 lines)
```typescript
// File: app_video_card.tsx
// Replace `{/* App info in step after */}` with:

<Stack space="small">
  <Box borderRadius="small" overflow="hidden">
    <StaticImage src={iconUrl} alt={title} />
  </Box>
  <Text size="large" weight="bold" color={headingColor}>
    {heading}
  </Text>
  <Text size="small" color="secondary">
    {subheading}
  </Text>
</Stack>
```

**Validation After Step 3d:**
```bash
grep "StaticImage" app_video_card.tsx
grep "<Stack space" app_video_card.tsx
wc -l app_video_card.tsx
```
Expected: Both matches found, total lines ‚â§73 (within budget if types are separate file)

‚úÖ **Final Checkpoint**
```

**Benefits of Proper Sizing:**
- Each step: 10-18 lines (easily digestible)
- AI validates progress after each step
- Failures caught immediately at source
- Clear progression from simple to complete
- Easy to debug which specific step failed

---

## Principle 5: Referenced Over Assumed

Don't assume AI knows your codebase patterns. Show actual code from existing files.

[Previous content retained - same as before]

---

## Success Criteria vs Validation Scripts Separation

**Critical Concept:** These are TWO DIFFERENT THINGS that must be in separate sections.

### Success Criteria Section
**Purpose:** State WHAT must be true (human-readable goals)

**Format:**
```markdown
## Success Criteria (OBJECTIVE ONLY - NO VALIDATION COMMANDS HERE)

- [ ] Component uses Box from Easel for container
- [ ] Props interface extends EditorialFeaturedAppProps
- [ ] No else blocks used in conditional rendering
- [ ] TypeScript compiles with 0 errors
```

**Rules:**
- Describes WHAT must be true
- No bash commands
- No expected outputs
- Objective statements only

---

### Validation Scripts Section
**Purpose:** Specify HOW to verify it's true (machine-executable checks)

**Format:**
```markdown
## Validation Scripts (MANDATORY - SEPARATE SECTION)

**Validation 1: Easel Box Usage**
```bash
grep "import { Box } from '@canva/ui/box'" component.tsx
```
Expected: Match found

**Validation 2: Props Extension**
```bash
grep "EditorialFeaturedAppProps &" types.ts
```
Expected: Match found

**Validation 3: No Else Blocks**
```bash
grep " else " component.tsx
```
Expected: No matches

**Validation 4: TypeScript Compilation**
```bash
npm run typecheck
```
Expected: "0 errors", exit code 0
```

**Rules:**
- Maps to Success Criteria (one-to-one or many-to-one)
- Includes bash commands
- Specifies expected outputs
- Numbered sequentially

---

### Why Separate?

**Clarity:** Success Criteria readable by humans, Validation Scripts executable by machines
**Maintenance:** Can update validation commands without changing criteria
**Flexibility:** Same criterion can map to multiple validations
**Organization:** Clear separation of concerns

**Example Mapping:**
```
Success Criterion: "Component uses Easel components exclusively"

Maps to 3 Validations:
  1. Check Easel imports present
  2. Check no .css files
  3. Check no inline styles
```

---

## Before/After Task Definition Examples

[Previous examples retained, updated to show ValidationScripts separation]

---

## Common AI Failure Patterns & Fixes

[Previous patterns retained - same as before]

---

## Task Definition Quality Checklist

Use this before finalizing any task for user approval:

### Mandatory Sections

- [ ] CodeContext - with file paths, line numbers, code snippets
- [ ] StyleGuides - with .mdc references and explicit DO/DON'T
- [ ] State Management Strategy - for UI components (MobX YES/NO)
- [ ] Requirements - using "Given [X], should [Y]" format
- [ ] Success Criteria - OBJECTIVE statements only, NO validation commands
- [ ] Validation Scripts - SEPARATE section mapping criteria to validations
- [ ] Implementation Steps - with exact code for each step

### Content Quality

- [ ] No subjective terms in success criteria - Run check:
  ```bash
  grep -A 100 "## Success Criteria" task.md | \
    grep -i -E "distinct|clean|proper|appropriate|nice|elegant|suitable|good|better"
  ```
  Expected: No matches

- [ ] Validation Scripts separate from Success Criteria
- [ ] Each success criterion maps to ‚â•1 validation
- [ ] All code examples follow StyleGuide patterns
- [ ] All imports have exact paths (no wildcards)
- [ ] Task size ‚â§50 lines (or broken into sub-tasks)
- [ ] Each implementation step ‚â§20 lines
- [ ] Validation after each step
- [ ] Expected outputs specified for all validations

### AI Executability

- [ ] Everything AI needs is explicit (no assumptions)
- [ ] Can copy-paste code directly from task
- [ ] Can copy-paste validation commands
- [ ] Can verify completion objectively
- [ ] No human judgment required at any step

---

## Red Flags in Task Definitions

**If you see these, task needs revision:**

üö© Subjective terms in criteria: "distinct", "clean", "proper", "appropriate", "good", "nice", "elegant"
üö© Validation commands in Success Criteria section (belong in ValidationScripts)
üö© "Follow best practices" without specifics
üö© "Use appropriate settings" without exact values
üö© "Figure out", "determine", "choose" language
üö© Implementation step >20 lines
üö© Success criteria without mapping to ValidationScripts
üö© Code examples with custom CSS (if Easel required)
üö© Code examples with else blocks (if early returns required)
üö© Import paths missing or using wildcards
üö© No CodeContext section
üö© No StyleGuides section
üö© Task >50 lines without breakdown

---

## Green Flags in Task Definitions

**These indicate AI-ready tasks:**

‚úÖ CodeContext with actual code snippets from existing files
‚úÖ StyleGuides with explicit DO/DON'T and code examples
‚úÖ Success Criteria with objective statements (WHAT must be true)
‚úÖ ValidationScripts as separate section (HOW to verify)
‚úÖ Each criterion maps to validation(s)
‚úÖ Exact code in implementation steps (‚â§20 lines each)
‚úÖ Validation after each step with expected outputs
‚úÖ Import paths are exact and complete
‚úÖ Task ‚â§50 lines or broken into sub-tasks
‚úÖ Requirements use "Given [X], should [Y]" format
‚úÖ No subjective language anywhere
‚úÖ State Management Strategy explicit (MobX YES/NO)

---

## Template for Quick Task Writing

```markdown
# Task X: [Specific Action in ‚â§50 Lines]

[One-line description]

## CodeContext (MANDATORY)

**File:** `exact/path/file.ext` (Lines X-Y)
```language
[actual current code AI needs to see]
```

## StyleGuides (MANDATORY)

**Mandatory:** `guide.mdc` - Section: [specific section]

**Constraints:**
‚úÖ **DO:** [with code example]
‚ùå **DON'T:** [with anti-pattern example]

## State Management Strategy

**MobX Required:** [YES/NO]
**Justification:** [reason]

## Requirements

- Given [situation], should [action]

## Success Criteria (OBJECTIVE - NO VALIDATIONS HERE)

- [ ] [Objective statement of WHAT must be true]
- [ ] [Another objective statement]

## Validation Scripts (SEPARATE SECTION)

**Validation 1: [Maps to criterion 1]**
```bash
[command]
```
Expected: [output]

**Validation 2: [Maps to criterion 2]**
```bash
[command]
```
Expected: [output]

## Implementation Steps

**Step 1:** [action] (‚â§20 lines)
```language
[exact code]
```
**Validation:** `command` ‚Üí Expected: [output]
‚úÖ **Checkpoint**

## Estimated Effort

**Size:** Small
**Time:** 1h
**Lines:** ~X lines
**Reference:** [example from calibration.mdc]
```

---

## Final Checklist

Before submitting task to AI:

1. **Run automated subjective check** - No forbidden terms?
2. **Verify section separation** - ValidationScripts not in Success Criteria?
3. **Check step sizes** - All ‚â§20 lines?
4. **Validate orchestration logic** - Decision matches domain count?
5. **Test validation commands** - Do they actually work?

**If all ‚úÖ ‚Üí Task is AI-ready**
**If any ‚ùå ‚Üí Apply auto-revision rules**
