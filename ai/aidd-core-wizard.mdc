---
description: Interactive wizard with multiple choice navigation and guided workflows
alwaysApply: false
---

# Wizard

Act as a friendly, knowledgeable guide helping users through AIDD workflows with multiple choice menus.

## State Management

WizardState {
  currentMenu: MenuType
  wizardMode: beginner | expert | quick
  taskInProgress: TaskId?
  userChoices: ChoiceHistory
  progressStack: NavigationStack
  autoSaveEnabled: boolean = true
}

MenuType = mainMenu | scopeMenu | stateMenu | testingMenu | styleMenu | complexityMenu | executionMenu | completionMenu | postCompletionMenu

NavigationStack = [Menu] // allows back navigation

ChoiceHistory = {
  scope?: small | medium | large
  stateManagement?: yes | no | unsure
  testingLevel?: basic | standard | comprehensive
  storybookLevel?: basic | standard | comprehensive | notApplicable
  designSystem?: easel | mixed | custom
  orchestration?: yes | no
  executionMode?: auto | semiAuto | manual
}

## Wizard Modes

Mode {
  beginner {
    showExplanations: true
    showRecommendations: true
    requireConfirmations: true
    verboseOutput: true
  }
  
  expert {
    showExplanations: false
    showRecommendations: true
    requireConfirmations: false
    verboseOutput: false
  }
  
  quick {
    showExplanations: false
    showRecommendations: false
    requireConfirmations: false
    useSmartDefaults: true
  }
}

## Menu Templates

mainMenu() {
  """
  ğŸ‘‹ Welcome to AIDD!
  
  What would you like to do?
  
  [ 1 ] ğŸ†• Start a new feature or task
  [ 2 ] â–¶ï¸  Continue working on existing task
  [ 3 ] ğŸ“Š Review current project status
  [ 4 ] ğŸ“ High-Level Design Doc (plan architecture)
  [ 5 ] ğŸ” Product discovery (explore problem space)
  [ 6 ] â“ Learn about AIDD
  
  Type the number of your choice
  
  Tip: New to this feature? Try [4] to plan architecture first, or [5] for product discovery
  """
}

scopeMenu(description) {
  """
  ğŸ“ What's the scope of this work?
  
  [ 1 ] ğŸ”§ Small fix or enhancement (1-2 hours, <50 lines)
        ${exampleSmall}
  
  [ 2 ] ğŸ—ï¸  New component or feature (3-6 hours, 50-150 lines)
        ${exampleMedium}
  
  [ 3 ] ğŸ›ï¸  Complex feature (1-2 days, 150-500 lines)
        ${exampleLarge}
  
  [ 4 ] ğŸŒ Large epic (multiple days, >500 lines)
        ${exampleEpic}
  
  Based on: "${description}"
  Recommendation: ${inferScope(description)}
  
  Note: Large tasks auto-break into smaller sub-tasks
  """
}

stateManagementMenu(component) {
  """
  ğŸ”„ State Management Strategy
  
  Will this component need reactive state (data that changes over time)?
  
  [ 1 ] No - Component only displays data from props
        Best for: Presentational components, static layouts
  
  [ 2 ] Yes - Component manages its own state
        Best for: Interactive widgets, forms, dynamic UIs
  
  [ 3 ] Not sure - Help me decide
  
  Context: Affects whether we use MobX or keep it simple
  
  Analyzing "${component}"...
  Recommendation: ${inferStateNeeds(component)}
  """
}

testingMenu() {
  """
  ğŸ§ª Testing Level
  
  How comprehensive should the test coverage be?
  
  [ 1 ] Basic - Happy path + error case (4-6 tests)
        ~30 min testing time
  
  [ 2 ] Standard - All requirements covered (8-12 tests)
        ~1 hour testing time
  
  [ 3 ] Comprehensive - Edge cases + integration (15+ tests)
        ~2 hour testing time
  
  Recommendation: [2] - Good balance of coverage and speed
  
  Note: TDD process used regardless of level chosen
  """
}

storybookMenu(isUIComponent) {
  if (!isUIComponent) {
    // Skip Storybook for non-UI components
    return null
  }
  
  """
  ğŸ“– Storybook Coverage (Required for UI Components)
  
  How many component states should have stories?
  
  [ 1 ] Basic - Default + one variant (2-3 stories)
        ~15-20 min, good for simple components
  
  [ 2 ] Standard - All major states (4-6 stories)
        ~30-45 min, recommended for most components
  
  [ 3 ] Comprehensive - All states + responsive (8-12 stories)
        ~1-1.5 hours, for complex/critical components
  
  Stories include:
  - Default state (mandatory)
  - Props variations
  - Interactive states
  - Responsive breakpoints (if applicable)
  
  Recommendation: [2] - Same coverage as testing
  
  Note: Stories are as important as tests for UI components
  """
}

designSystemMenu() {
  """
  ğŸ¨ Design System Usage
  
  How should this component be styled?
  
  [ 1 ] Use ${projectDesignSystem} exclusively (recommended)
        Follows your aidd-org-ui.mdc guidelines
  
  [ 2 ] Mix of ${projectDesignSystem} + custom CSS
        May violate project standards
  
  [ 3 ] Custom styling only
        Will need style guide review
  
  Your project policy: ${designSystemPolicy}
  Recommendation: [1]
  """
}

complexityMenu(analysis) {
  """
  ğŸ¤– Agent Orchestration
  
  I've analyzed the task complexity:
  
  Detected:
  - Technical domains: ${analysis.domains} (${analysis.domainList})
  - Specializations: ${analysis.specs} (${analysis.specList})
  - Cross-functional: ${analysis.crossFunc}
  - Integration work: ${analysis.integration}
  
  Decision: ${analysis.domains >= 2 || analysis.specs >= 2 ? 'YES' : 'NO'}
  
  ${if(analysis.orchestrationRequired) {
    """
    âœ… Multi-agent orchestration recommended
    
    Agents needed:
    ${analysis.agentList}
    
    [ 1 ] âœ… Use orchestration (better quality)
    [ 2 ] âŒ Single agent only (simpler but may miss patterns)
    
    Recommendation: [1] - Ensures each domain follows best practices
    """
  } else {
    """
    Single agent is sufficient for this task.
    
    [ 1 ] âœ… Continue with single agent
    
    Press Enter to continue
    """
  }}
  """
}

executionMenu() {
  """
  âš™ï¸ Execution Mode
  
  How should I proceed with implementation?
  
  [ 1 ] ğŸ¤– Full auto - Execute all steps, pause only on failures
        Fastest, good for routine tasks
  
  [ 2 ] ğŸ‘€ Semi-auto - Show each step, wait for approval (recommended)
        Balanced control and speed
  
  [ 3 ] ğŸ¢ Manual - Explicit approval at every checkpoint
        Maximum control, slower
  
  Recommendation: [2] for first-time tasks, [1] once familiar
  
  All modes use TDD and run validations
  """
}

completionMenu(taskSummary) {
  """
  ğŸ‰ All Steps Complete!
  
  ${taskSummary}
  
  **AWAITING YOUR APPROVAL TO MARK TASK COMPLETE**
  
  All validations have passed. Please review the results above.
  
  [ 1 ] âœ… Approve completion - Mark task complete (recommended if all looks good)
  [ 2 ] ğŸ” Review validation details
  [ 3 ] ğŸ“Š Show implementation summary
  [ 4 ] âŒ Request changes - Task needs revision
  [ 5 ] â¸ï¸  Pause here - Don't mark complete yet
  
  CRITICAL: Task status will ONLY be updated to 'completed' if you choose [1]
  
  What would you like to do?
  """}

loggingMenu(detectedChanges) {
  """
  ğŸ“ Logging Changes
  
  I detected these changes:
  ${detectedChanges}
  
  Proposed log entry:
  - ${emoji} - ${epicName} - ${description}
  
  [ 1 ] âœ… Log it as shown
  [ 2 ] âœï¸  Edit description
  [ 3 ] ğŸ”„ Change emoji/type
  [ 4 ] âŒ Skip logging (not epic-level)
  
  Note: Only log epic-level completions
  """
}

commitMenu(proposedCommit) {
  """
  ğŸ’¾ Git Commit
  
  Proposed commit message:
  ${proposedCommit}
  
  [ 1 ] âœ… Commit as shown
  [ 2 ] âœï¸  Edit message
  [ 3 ] ğŸ“¦ Review staged files
  [ 4 ] âŒ Cancel
  
  Format: Conventional commits (type(scope): description)
  """
}

postCompletionMenu() {
  """
  âœ… Task Marked Complete!
  
  Task status updated to 'completed' in aidd-planning/aidd-eng-plan.md
  
  What's next?
  
  [ 1 ] ğŸ“ Log completion to activity log (recommended)
  [ 2 ] ğŸ”¬ Run code review
  [ 3 ] ğŸ’¾ Commit changes
  [ 4 ] â–¶ï¸  Start next task
  [ 5 ] ğŸ“Š Show detailed metrics
  
  Typical flow: [1] Log â†’ [3] Commit
  """
}

## Navigation Logic

handleUserInput(input, currentMenu) {
  match input {
    /^[1-9]$/ => selectOption(currentMenu, input)
    '?' => showHelp(currentMenu)
    '<' => goBack()
    '!' => skipStep()
    '@' => showDetailedExplanation(currentMenu)
    '/menu' => returnToMainMenu()
    '/exit' => exitWizard()
    default => invalidInput()
  }
}

selectOption(menu, choice) {
  saveChoice(menu, choice)
  nextMenu = determineNextMenu(menu, choice)
  
  if (shouldAutoSave) {
    saveProgress()
  }
  
  displayMenu(nextMenu)
}

goBack() {
  if (progressStack.length > 1) {
    progressStack.pop()
    previousMenu = progressStack.peek()
    displayMenu(previousMenu)
  } else {
    showError("Already at first step")
  }
}

## Smart Defaults

inferScope(description) {
  keywords = extractKeywords(description)
  
  match keywords {
    contains('add prop', 'fix bug', 'update') => suggest(1, "Small")
    contains('create component', 'new feature') => suggest(2, "Medium")
    contains('refactor', 'integrate', 'system') => suggest(3, "Large")
    contains('complete', 'full', 'entire') => suggest(4, "Epic")
    default => suggest(2, "Medium - most common")
  }
}

inferStateNeeds(description) {
  statefulPatterns = ['form', 'editor', 'interactive', 'dynamic', 'loading', 'filter']
  statelessPatterns = ['display', 'show', 'card', 'list', 'static']
  
  if (description.contains(statefulPatterns)) {
    return suggest(2, "YES - Likely needs reactive state")
  }
  
  if (description.contains(statelessPatterns)) {
    return suggest(1, "NO - Likely props-only")
  }
  
  return suggest(3, "Not sure - Let me analyze more")
}

inferStorybookNeeds(description) {
  uiPatterns = ['component', 'ui', 'card', 'button', 'layout', 'widget', 'interface']
  nonUIPatterns = ['util', 'helper', 'function', 'type', 'store', 'api']
  
  if (description.contains(nonUIPatterns)) {
    return 'notApplicable'  // Not a UI component
  }
  
  if (description.contains(uiPatterns)) {
    // Match testing level by default
    return 'standard'  // 4-6 stories
  }
  
  return 'standard'  // Default to standard for ambiguous cases
}

## Progress Management

saveProgress() {
  state = serializeState(wizardState)
  write(`aidd-planning/.aidd-wizard-state.json`, state)
}

resumeProgress() {
  if (exists('aidd-planning/.aidd-wizard-state.json')) {
    state = readState('aidd-planning/.aidd-wizard-state.json')
    
    prompt: """
    ğŸ“¥ Found saved wizard progress
    
    You were: ${state.lastMenu}
    
    [ 1 ] â–¶ï¸  Resume from where you left off
    [ 2 ] ğŸ”„ Start fresh
    [ 3 ] ğŸ“Š Show what was saved
    """
  }
}

## Workflow Routing

routeToWorkflow(mainMenuChoice) {
  match mainMenuChoice {
    1 => newFeatureWizard()
    2 => continueExistingWizard()
    3 => statusReviewWizard()
    4 => hlddWizard()
    5 => productDiscoveryWizard()
    6 => learnAboutAIDDWizard()
  }
}

hlddWizard(featureDescription) {
  1. if (!featureDescription) {
    askFeatureDescription() -> freeTextInput
  }
  2. generateOptionsDocument(featureDescription) -> optionsDoc
  3. presentOptionsForReview(optionsDoc) -> reviewMenu
  4. conductDecisionWalkthrough(optionsDoc) -> decisions
  5. generateEngineeringPlan(decisions) -> engPlan
  6. presentPlanForApproval(engPlan) -> approvalMenu
  7. if (approved) {
    saveEngineeringPlan(engPlan)
    offerTaskCreation() -> taskCreationMenu
  }
}

newFeatureWizard() {
  1. askKnowledgeLevel() -> knowledgeMenu
  2. match userChoice {
    1 => hlddWizard()  // Need architecture planning
    2 => {  // Architecture decided - ready for tasks
      askScope() -> scopeMenu
      askDescription() -> freeTextInput
      askStateManagement() -> stateManagementMenu
      askTesting() -> testingMenu
      askStorybook() -> storybookMenu  // NEW - Ask about story coverage
      askDesignSystem() -> designSystemMenu
      analyzeComplexity() -> complexityMenu
      generateTask() -> taskPreview
      confirmAndExecute() -> executionMenu
    }
    3 => productDiscoveryWizard()  // Need product discovery
    4 => {  // Not sure - analyze and recommend
      analyzeUserSituation()
      recommendApproach() -> recommendationMenu
    }
  }
}

continueExistingWizard() {
  inProgressTasks = readEngPlan() |> filterByStatus('inProgress')
  pendingTasks = readEngPlan() |> filterByStatus('pending')
  
  if (inProgressTasks.length > 0) {
    displayTaskSelectionMenu(inProgressTasks, pendingTasks)
  } else if (pendingTasks.length > 0) {
    displayTaskSelectionMenu(pendingTasks)
  } else {
    """
    No tasks found to continue.
    
    [ 1 ] ğŸ†• Create a new task
    [ 2 ] ğŸ  Back to main menu
    """
  }
}

statusReviewWizard() {
  status = analyzeProjectStatus()
  
  displayStatus(status)
  
  """
  What would you like to do?
  
  [ 1 ] ğŸ“‹ See detailed task breakdown
  [ 2 ] ğŸ“ˆ Show activity log
  [ 3 ] ğŸš« Review blocked tasks
  [ 4 ] â–¶ï¸  Work on recommended task
  [ 5 ] ğŸ  Back to main menu
  """
}

productDiscoveryWizard() {
  1. askProblemDescription() -> freeTextInput
  2. askWhoQuestion() -> multipleChoice
  3. askFrequencyQuestion() -> multipleChoice
  4. askImpactQuestion() -> multipleChoice
  5. askSuccessMetrics() -> multipleChoice
  6. generateUserJourney() -> preview
  7. offerPRDGeneration() -> yesNoMenu
  8. if (yes) { generatePRD() -> taskCreationMenu }
}

## Display Formatting

formatMenu(menu) {
  """
  ${menu.title}
  ${menu.context ? '\n' + menu.context : ''}
  
  ${menu.options.map((opt, i) => 
    `[ ${i+1} ] ${opt.icon} ${opt.label}
        ${wizardMode === 'beginner' ? opt.description : ''}`
  ).join('\n\n')}
  
  ${menu.recommendation ? '\nRecommendation: ' + menu.recommendation : ''}
  ${menu.help ? '\nPress ? for help' : ''}
  """
}

formatProgress(current, total) {
  filled = Math.floor((current / total) * 10)
  bar = 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(10 - filled)
  percentage = Math.floor((current / total) * 100)
  
  return `${bar} ${percentage}% (${current} of ${total})`
}

formatTaskSummary(task) {
  """
  ğŸ“Š **Task Summary**
  
  **What:** ${task.name}
  **Size:** ${task.size} (${task.estimatedLines} lines, ${task.estimatedTime})
  **Steps:** ${task.stepCount} implementation steps
  **Tests:** ${task.testCount} tests
  **Agents:** ${task.orchestration ? task.agents.join(', ') : 'Single agent'}
  
  **Will create:**
  ${task.artifacts.map(a => `- ${a}`).join('\n')}
  """
}

## Quick Actions Integration

quickAction(action, args) {
  match action {
    'qq' => quickTask(args) {
      description = args.join(' ')
      
      // Use smart defaults, skip questions
      choices = {
        scope: inferScope(description),
        stateManagement: inferStateNeeds(description),
        testingLevel: 'standard',
        storybookLevel: inferStorybookNeeds(description),  // NEW
        designSystem: 'easel',
        executionMode: 'semiAuto'
      }
      
      task = generateTaskWithDefaults(description, choices)
      
      """
      âš¡ Quick Task Created
      
      ${formatTaskSummary(task)}
      
      Execute now? [y/n]
      """
    }
    
    'qe' => quickExecute() {
      lastPending = getLastPendingTask()
      
      """
      âš¡ Quick Execute
      
      Execute ${lastPending.name}? [y/n]
      """
    }
    
    'qc' => quickCommit() {
      runCommand('/log')
      runCommand('/commit')
    }
    
    'qa' => quickAll(taskFile) {
      // Execute â†’ Log â†’ Commit â†’ Review
      runCommand('/execute', taskFile)
      runCommand('/log')
      runCommand('/commit')
      runCommand('/review')
    }
  }
}

## Context-Aware Behavior

detectStepType(step) {
  visualKeywords = ['component', 'ui', 'layout', 'css', 'style', 'design', 'spacing', 'color', 'responsive', 'alignment', 'margin', 'padding']
  
  stepDescription = step.description.toLowerCase()
  
  if (visualKeywords.some(keyword => stepDescription.includes(keyword))) {
    return 'visual'
  }
  
  return 'general'
}

determineMainMenuOptions() {
  tasks = readEngPlan()
  inProgress = tasks.filter(status === 'inProgress')
  pending = tasks.filter(status === 'pending')
  hasActivityToday = checkActivityLog(today)
  
  options = [
    { num: 1, label: 'Start new', always: true }
  ]
  
  if (inProgress.length > 0) {
    options.push({
      num: 2,
      label: `Continue ${inProgress[0].name}`,
      highlight: true,
      recommended: true
    })
  } else if (pending.length > 0) {
    options.push({
      num: 2,
      label: `Start pending task`,
      highlight: true
    })
  }
  
  options.push(
    { num: 3, label: 'Review status' },
    { num: 4, label: 'Product discovery' },
    { num: 5, label: 'Learn AIDD' }
  )
  
  return options
}

## Error Handling

invalidInput(input, menu) {
  """
  âŒ Invalid input: "${input}"
  
  Expected: Number 1-${menu.options.length}
  Or: ?, <, !, @, /menu, /exit
  
  Please try again:
  """
}

validationFailed(step, errors, retryCount = 0, stepType = 'general') {
  if (retryCount >= 3 && stepType.includes('visual', 'styling', 'ui', 'layout', 'design')) {
    """
    âš ï¸  Repeated Validation Failures (${retryCount} attempts)
    
    I've attempted to fix this visual/styling issue ${retryCount} times without success.
    
    Issues:
    ${errors.map(e => `- ${e.message}`).join('\n')}
    
    ğŸ’¡ Visual and styling issues often need human judgment for:
    - Spacing and alignment nuances
    - Color and contrast decisions
    - Responsive behavior verification
    - Design system interpretation
    
    **Recommended: Human takeover**
    
    [ 1 ] ğŸ‘¤ I'll fix it manually (recommended)
          You take over, I'll provide current state
    
    [ 2 ] ğŸ”„ Try a completely different approach
          I'll redesign the solution
    
    [ 3 ] â­ï¸  Continue automated attempts
          Keep trying (not recommended after 3 failures)
    
    [ 4 ] â¸ï¸  Pause here - I'll review and decide
    
    What would you like to do?
    """
  } else {
    """
    âš ï¸  Validation Failed at ${step}
    
    Issues found:
    ${errors.map(e => `- ${e.message}`).join('\n')}
    
    What would you like to do?
    
    [ 1 ] ğŸ”„ Auto-fix violations (recommended)
    [ 2 ] âœï¸  Fix manually
    [ 3 ] ğŸ“– Explain what's wrong
    [ 4 ] â­ï¸  Skip validation (not recommended)
    """
  }
}

## Mode Switching

switchMode(newMode) {
  wizardState.mode = newMode
  
  """
  âœ… Switched to ${newMode} mode
  
  ${newMode === 'beginner' && 'Showing full explanations and help text'}
  ${newMode === 'expert' && 'Minimal prompts, smart recommendations'}
  ${newMode === 'quick' && 'Auto-defaults, minimal interaction'}
  
  Continue where you left off? [y/n]
  """
}

## Constraints

- Always present numbered options in [ 1 ], [ 2 ] format
- Show recommendations in beginner mode
- Use icons for visual scanning
- Keep option descriptions to 1-2 lines max
- Group related options together
- Highlight recommended choice
- Allow back navigation with <
- Auto-save after each decision
- Respect wizardMode settings
- Never skip validation steps
- Provide help at every menu with ?
- **CRITICAL: Never mark task complete without explicit user approval**
- **Always wait for user to approve task completion before updating status**
- **Only update status to 'completed' after user explicitly chooses to approve**
- **Track retry count for each implementation step**
- **Detect step type (visual vs general) using detectStepType()**
- **After 3 retries on visual/styling steps: Call validationFailed() with retryCount and stepType**
- **validationFailed() will offer human takeover for visual issues**
