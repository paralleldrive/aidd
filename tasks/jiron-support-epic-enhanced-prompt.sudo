# Enhanced Prompt - Jiron Support

## Goal
Enable self-describing APIs that agents browse with ONE generic capability - replacing explicit tool definitions (MCP).

## Paradigm Shift
MCP {
  model: predefined tools per API
  requires: tool manifests, schemas, per-API implementations
  scales: poorly (N tools for N APIs)
}

Jiron {
  model: self-describing APIs via hypermedia
  requires: ONE browse capability
  scales: infinitely (1 capability for N APIs)
  analogy: browsers don't need tools.json for websites
}

## Context
Jiron {
  base: Siren semantics + Jade syntax
  output: valid HTML (browser-renderable, machine-parseable)
  advantages: hypermedia affordances, code-on-demand, self-documenting APIs
  key: actions embedded in responses, not predefined in manifests
}

Siren {
  type: "application/vnd.siren+json"
  structure: { class, properties, entities, links, actions, title }
  entities: URI-addressable resources with state + transitions
  subEntities: embedded links | embedded representations (require rel)
  links: navigational (rel, href, class, title, type)
  actions: behaviors (name, href, method, class, fields)
}

## Deliverables

JironServer {
  purpose: AI agent builds Jiron APIs from functional requirements
  input: task requirements (Given/should format)
  output: Jiron-compliant hypermedia endpoints
  rule: create "ai/rules/jiron-server.mdc"
  command: create "ai/commands/jiron-api.md"
}

JironClient {
  purpose: dynamically build web components from Jiron endpoints
  input: Jiron API endpoint URL
  output: web components supporting Siren semantics
  features:
    - entity rendering (properties, subentities)
    - link traversal (rel-based navigation)
    - action forms (HTTP method support)
    - URI-based entity IDs (enables sidelining vs embedding)
  rule: create "ai/rules/jiron-client.mdc"
  command: create "ai/commands/jiron-component.md"
}

DualRenderViews {
  purpose: SEO + agent-friendly page rendering
  browser: standard HTML
  agent: token-efficient Jiron at "path/page.jiron"
  discovery: <link rel="alternate" type="application/jiron" href="...">
  hint: HTML comment instructing agents to fetch .jiron variant
  rule: create "ai/rules/dual-render.mdc"
  command: create "ai/commands/dual-view.md"
}

JironAgent {
  purpose: guide AI agents in browsing Jiron APIs
  model: fetch root → discover links/actions → navigate → execute → repeat
  requires: no predefined tool knowledge
  rule: create "ai/rules/jiron-agent.mdc"
}

StreamingMiddleware {
  purpose: portable streaming responses for AI/chat
  file: "src/server/middleware/with-stream.js"
  pattern: generator → ReadableStream → chunked HTTP
  portability: Web Streams API only (no Node.js streams)
}

## Server Framework
AIDD {
  pattern: createRoute + asyncPipe (functional composition)
  NOT: Express
  middleware: ({ request, response }) => Promise<{ request, response }>
  data: attach to response.locals
}

## Streaming
WebStreamsAPI {
  why: portability (no Vercel vendor lock-in)
  primitives: ReadableStream, TransformStream, TextEncoderStream
  pattern: generator → ReadableStream → chunked response
  works: Node.js, Deno, Vercel, Netlify, AWS Lambda, Deno Deploy
  avoid: Node.js-specific streams (fs.ReadStream, etc.)
}

## Constraints
- Follow existing aidd patterns (see ai/rules/, ai/commands/, src/server/)
- Use createRoute + asyncPipe, NOT Express
- Streaming via Web Streams API only (no vendor lock-in)
- TDD for any implementation code
- Requirements use "Given X, should Y" format
- Verify against: jiron spec, siren spec, existing codebase conventions

## References
- https://github.com/ericelliott/jiron
- https://github.com/kevinswiber/siren
- https://github.com/ericelliott/siren-resource (deprecated, pattern reference only)
